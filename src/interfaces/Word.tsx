import {
  Xing,
  XingWord,
  makeXingWord,
  getCandFromHalfDispXing,
  getNonCandFromHalfDispXing
} from "./Xing";
import {
  PuzModelCell,
  Coords,
  getCoordsGeneric,
  areCoordsSafe,
  getSurroundCells,
  getWordCandCells
} from "./PuzModelCell";

export interface Word {
  word: string;
  coords: Coords[] | null;
  isAcross: boolean | null;
}

export interface WordCandidate {
  xingWordCandidate: XingWord;
  wordCells: PuzModelCell[];
  surroundCells: (PuzModelCell | undefined)[];
  dispWord: string;
}

export const makeWordCandidate = (
  xingWordCand: XingWord,
  coordsCand: Coords[],
  dispWord: string,
  puzModel: PuzModelCell[][]
): WordCandidate => {
  // Bounds check word cells with getWordCoordsFromLetterCoords before calling this func.
  return {
    xingWordCandidate: xingWordCand,
    wordCells: getWordCandCells(coordsCand, puzModel),
    surroundCells: getSurroundCells(xingWordCand, coordsCand, puzModel),
    dispWord: dispWord
  };
};

export const makeWordCandsFromHalfDispXings = (
  halfDispXings: Xing[],
  words: Word[],
  puzModel: PuzModelCell[][]
): WordCandidate[] => {
  // This func loops through xings generated by getHalfDisplayedXings
  // and creates word candidates from them, only if they are in bounds.
  const ret: WordCandidate[] = [];
  let letterCoordsCand: Coords;
  let wordCoordsCand: Coords[] | undefined;
  let xingWordCand: XingWord;
  let xingWordNonCand: XingWord; // Displayed word.
  for (let xing of halfDispXings) {
    xingWordCand = getCandFromHalfDispXing(xing);
    xingWordNonCand = getNonCandFromHalfDispXing(xing);
    letterCoordsCand = getWordCoords(getWord(words, xingWordNonCand.word))[
      xingWordNonCand.letterIdxInWord
    ];
    wordCoordsCand = getWordCoordsFromLetterCoords(
      xingWordCand,
      letterCoordsCand,
      puzModel
    );
    // Only in-bounds words are candidates.
    if (wordCoordsCand)
      ret.push(
        makeWordCandidate(
          xingWordCand,
          wordCoordsCand,
          xingWordNonCand.word,
          puzModel
        )
      );
  }
  return ret;
};

export const getWord = (words: Word[], wordStr: string): Word => {
  return { ...(words.find(word => word.word === wordStr) as Word) };
};

export const makeWord = (word: string): Word => {
  return {
    word: word,
    coords: null,
    isAcross: null
  };
};

export const getUpdatedWord = (
  oldWord: string,
  isAcross: boolean,
  coords: Coords[]
): Word => {
  return {
    word: oldWord,
    isAcross: isAcross,
    coords: coords
  };
};

export const getWordCoordsFromLetterCoords = (
  xingWord: XingWord,
  letterCoords: Coords,
  puzModel: PuzModelCell[][]
): Coords[] | undefined => {
  const wordCoords: Coords[] = [];
  const dynamicDirection: number = xingWord.isAcross ? 1 : 0;
  const staticDirection: number = !xingWord.isAcross ? 1 : 0;
  const staticPos: number = letterCoords[staticDirection];
  const offset: number =
    letterCoords[dynamicDirection] - xingWord.letterIdxInWord;
  wordCoords.push(letterCoords);
  for (let i = xingWord.letterIdxInWord - 1; i >= 0; i--)
    wordCoords.splice(
      0,
      0,
      getCoordsGeneric(staticDirection, staticPos, dynamicDirection, i + offset)
    );
  for (let i = xingWord.letterIdxInWord + 1; i < xingWord.word.length; i++)
    wordCoords.push(
      getCoordsGeneric(staticDirection, staticPos, dynamicDirection, i + offset)
    );
  if (!wordCoords.every((lc: Coords) => areCoordsSafe(lc, puzModel))) return;
  return wordCoords;
};

export const getUpdatedFirstWord = (
  givenWord: Word,
  puzModel: PuzModelCell[][]
): Word | undefined => {
  const wordCoords: Coords[] | undefined = getWordCoordsFromLetterCoords(
    makeXingWord(givenWord.word, Math.floor(givenWord.word.length / 2), true),
    [Math.floor(puzModel.length * 0.75), Math.floor(puzModel[0].length / 2)],
    puzModel
  );
  return wordCoords
    ? getUpdatedWord(givenWord.word, true, wordCoords)
    : wordCoords;
};

export const getWordsWithUpdatedWord = (
  updatedWord: Word,
  words: Word[]
): Word[] => {
  return words.map((w: Word) =>
    w.word === updatedWord.word ? updatedWord : w
  );
};

export const getWordCoords = (word: Word): Coords[] => {
  return word.coords as Coords[];
};

export const getWordCoordsSafe = (word: Word): Coords[] | null => {
  return word.coords;
};

export const getDisplayedWords = (words: Word[]) => {
  // :coords: field of non-displayed words is null.
  return words.filter(word => getWordCoordsSafe(word)).slice();
};
